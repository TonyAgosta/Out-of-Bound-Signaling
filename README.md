# Out-of-bound-signaling
L'out-of-band signaling e` una tecnica di comunicazione in cui due entita` si scambiano informazioni senza trasmettersele direttamente, ma utilizzando segnalazione collaterale: per esempio, il numero di errori “artificiali”, o la lunghezza di un pacchetto pieno di dati inutili, o anche il momento esatto delle comunicazioni.
In questo caso, e` stato realizzato un sistema client-server, in cui i client possiedono un codice segreto (chiamato secret) e vogliono comunicarlo a un server centrale, senza pero trasmetterlo. Lo scopo e rendere difficile intercettare il secret a chi stia catturando i dati in transito.
In questo progetto ci sono "N" client, "K" server, e 1 Supervisor. Viene lanciato per primo il supervisor, con un parametro K che indica quanti server vogliamo attivare; il supervisor provvedera dunque a creare i K server (che dovranno essere processi distinti). Gli N client vengono invece lanciati indipendentemente, ciascuno in tempi diversi. Il funzionamento di ciascuno dei componenti e descritto nel seguito.
# Il Client
All'avvio, il client genera il suo secret, che e` costituito da un numero fra 1 e 3000, e il suo ID unico, che e un intero a 64 bit; entrambi devono essere generati pseudo-casualmente. Un client riceve sulla riga di comando tre valori interi P, K e W, con 1 ≤P< K e W >3P. Il secondo dovra` essere lo stesso passato al supervisor, che controlla quanti server sono attivi sul sistema.
All'inizio, il client deve stampare sul proprio stdout un messaggio nel formato “CLIENT id SECRET secret”, in cui id e` rappresentato da un numero esadecimale (senza prefissi particolari), e secret da un numero decimale. Il client dovra` quindi scegliere casualmente P interi distinti compresi fra 1 e K, e si colleghera` (tramite socket) ai P server corrispondenti agli interi scelti. Iniziera` un ciclo in cui, ad ogni iterazione, scegliera` casualmente un server fra i P a cui e` collegato, gli inviera` sulla socket corrispondente un messaggio contenente il proprio ID unico (il formato e` un buffer di 8 byte contenente l'ID in network byte order), e attende secret millisecondi prima di ripetere. Saranno inviati complessivamente W messaggi (in totale, non per ciascun server). Una volta completato il proprio compito, il client termina, dopo aver stampato un messaggio “CLIENT id DONE”.
# Il Server
Un server (che viene lanciato dal supervisor) per prima cosa apre una socket nel dominio AF_UNIX (come indirizzo e` stata utilizzata la stringa “OOB-server-i”, in cui i e` il suo numero progressivo fra 1 e K). Procede quindi ad attendere connessioni da parte dei client, che come detto possono arrivare in qualunque momento. Per ogni connessione, il server osserva il momento di arrivo dei messaggi da parte del client, e in particolare il tempo trascorso fra messaggi consecutivi. Per come e` strutturato il client, il tempo fra due messaggi consecutivi allo stesso server sara` un multiplo del suo secret. Compito del server e` di stimare il secret di ogni client, e – nel momento in cui la connessione viene chiusa da quel client – informare il supervisor di qual e` la sua migliore stima, inviando un messaggio che contenga l'ID del client e la sua stima del secret.
All'avvio il server stampa sul suo stdout un messaggio nel formato “SERVER i ACTIVE”. Per ogni nuova connessione ricevuta,stampa un messaggio “SERVER i CONNECT FROM CLIENT”. Per ogni messaggio ricevuto sulla socket, stampa su stdout un messaggio “SERVER i INCOMING FROM id@t”, in cui id e` l'ID del client che ha inviato il messaggio, e t e` il tempo di arrivo (espresso come un numero, con unita di misura a discrezione). Per ogni chiusura della socket, stampa su stdout un messaggio “SERVER i CLOSING id ESTIMATE s”, in cui s e` il valore stimato da questo client per il secret del client id.
Al momento della chiusura, il server comunica al supervisor la sua migliore stima per il valore del secret i id(la stessa stampata nel messaggio). La comunicazione fra server e supervisor e` realizzata tramite pipe anonime come descritto sotto.
# Il Supervisor
All'avvio, il supervisor stampa sul suo stdout un messaggio “SUPERVISOR STARTING k”, in cui k e` il numero di server che lancia (il supervisor riceve il parametro k come argomento sulla riga di comando). A questo punto, lancia (come processi distinti) i K server, e mantiene con ciascun server una connessione tramite pipe anonime con cui potra` ricevere le stime dei secret dei client da parte dei server. Per ogni nuova stima ricevuta, il supervisor stampa su stdout un messaggio “SUPERVISOR ESTIMATE s FOR id FROM i”, in cui s e` il valore della stima del secret,id e` l'ID del client a cui si riferisce la stima, e i e` l'indice del server che ha fornito la stima.
Il supervisor riceve stime da piu server per lo stesso client, utilizza quindi le diverse stime arrivate fino a un dato momento per determinare il valore piu probabile delsecret “vero”; chiamiamo questo valore Sid.Quando il supervisor riceve un segnale SIGINT, stampa sul suo stderr una tabella che mostra le sue stime correnti, in cui ciascuna riga ha il formato “SUPERVISOR ESTIMATES id FOR id BASED ON n” –in cui n rappresenta il numero di server che hanno fornito stime per id fino a quel momento. Se invece riceve un “doppio Ctrl-C”, ovvero un secondo segnale SIGINT a distanza di meno di un secondo dal precedente, il supervisor termina, stampando prima la stessa tabella su stdout seguita dal messaggio “SUPERVISOR EXITING”.
# Misura
E` stato realizzato uno script bash di nome misura che, ricevuti come argomenti i nomi di un insieme di file contenenti l'output di supervisor, server e client, ne legge e analizza i contenuti, e stampa delle statistiche su quanti secret sono stati correttamente stimati dal supervisor (intendendo per stima corretta un secret stimato con errore entro 25 unita rispetto al valore del secret vero), e sull'errore medio di stima.
# Makefile
Il progetto include un makefile avente, fra gli altri, i targetall(per generare tutti gli eseguibili), clean(per ripulire la directory di lavoro dai file generati), e test.Quest'ultimo esegue un ciclo completo di test, lanciando il supervisor con 8 server, e dopo un'attesa di 2 secondi lancia un totale di 20 client, ciascuno con parametri 5 8 20. I client vengono lanciati a coppie, e con un attesa di 1 secondo fra ogni coppia.
Dopo aver lanciato l'ultima coppia, il test attende 60 secondi, inviando nel frattempo un SIGINT al supervisor ogni 10 secondi; al termine invia un doppio SIGINT, e lancia lo script misura sui risultati raccolti (tramite redirezione dello stdout dei vari componenti su appositi file).
# Note finali
Nel realizzare il sistema oggetto del progetto, e` stato realizzato un protocollo di comunicazione fra supervisor e server  privato, mentre quello fra server e client e` pubblico. In altre parole, il sistema supervisor + server funziona anche se a connettersi sono client diversi da quelli sviluppati. Analogamente, i client saranno in grado di interoperare con supervisor+server sviluppati da altri.
